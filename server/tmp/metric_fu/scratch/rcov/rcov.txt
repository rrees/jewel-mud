[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m
      --------------------------
              STATISTICS
      --------------------------

        Locations: 657
        Exits: 1529
        Characters: 20

      --------------------------
    
[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m
      --------------------------
              STATISTICS
      --------------------------

        Locations: 1317
        Exits: 3060
        Characters: 38

      --------------------------
    
[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m[32m.[0m


Finished in 1.149338 seconds
[32m79 examples, 0 failures[0m
================================================================================
lib/game.rb
================================================================================
   class Game
     include Singleton
   
     attr_reader :world
   
     def initialize
       @world = World.new
       @command_manager = CommandManager.new
       @command_factory = CommandFactory.new
       @command_factory.aliases = {
         "s" => "go south", "n" => "go north", "w" => "go west", "e" => "go east",
         "u" => "go up", "d" => "go down", "l" => "look", "i" => "inventory", "inv" => "inventory"
       }
       @input_processor = InputProcessor.new(@command_factory, @command_manager)
       @shutdown_requested = false
     end
   
     def run
!!     Thread.abort_on_exception = true
!!     Thread.new do
!!       begin
!!         until @shutdown_requested
!!           @command_manager.process_commands
!!         end
!!       rescue Exception => e
!!         puts e.message
!!         puts e.backtrace.inspect
!!       ensure
!!         exit
!!       end
!!     end
!!   end
   
     def enter_game(session)
!!     authentication_process = AuthenticationProcess.new(session, @world)
!!     character = authentication_process.execute
!! 
!!     ############# NOT THREAD SAFE ###############################
!! 
!!     first_location = @world.locations.first
!!     character.move_to(first_location)
!!     first_location.let_in(character, nil)
!!     character.go("up")
!!     ##############################################################
!!     @input_processor.process_character_commands(character)
!!   end
   
     def shutdown
!!     @shutdown_requested = true
!!   end
!! end
================================================================================
lib/input_processor.rb
================================================================================
   class InputProcessor
     def initialize(command_factory, command_manager)
       @command_factory, @command_manager = command_factory, command_manager
     end
   
     def process_character_commands(character)
!!     loop do
!!       input = character.session.read
!!       cmd = @command_factory.parse(input, character)
!!       @command_manager.add_command(cmd)
!!     end
!!   end
!! end
================================================================================
lib/command_manager.rb
================================================================================
   require 'monitor.rb'
   
   class CommandManager
     def initialize()
       @commands = []
       @commands.extend(MonitorMixin)
       @empty_cond = @commands.new_cond
     end
   
     def add_command(command)
!!     @commands.synchronize do
!!       @commands.push(command)
!!       @empty_cond.signal
!!     end
!!   end
   
     def get_command
       @commands.synchronize do
!!       @empty_cond.wait_while { @commands.empty? }
!!       @commands.shift
!!     end
!!   end
   
     def process_commands
!!     command = get_command
!!     return if command.nil?
!!     command.execute
!!   end
!! 
!! end
================================================================================
jewel_mud.rb
================================================================================
   require 'gserver'
   require 'singleton'
   require 'yaml'
   
   Dir["lib/**/*.rb"].sort.each {|file| require file }
   
   
   class JewelMud < GServer
     def starting
!!     Game.instance.run
!!   end
   
     def serve(socket)
!!     telnet_session = TelnetSession.new(socket)
!!     Game.instance.enter_game(telnet_session)
!!   end
!! end
================================================================================
lib/commands/no_command_found.rb
================================================================================
   class NoCommandFound
     def initialize(character, args)
       @character = character
     end
   
     def execute
!!     @character.send_to_player("I beg you pardon? What are you trying to say?")
!!   end
!! end
================================================================================
lib/game/item.rb
================================================================================
   class Item
     attr_reader :name, :item, :description
     def initialize(name, description)
       @name, @description = name, description
     end
   
     def description_for(character)
!!     @description
!!   end
!! end
================================================================================
lib/game/world.rb
================================================================================
   class World
     attr_reader :locations
   
     def initialize
       @locations = []
       @characters = []
       load_world
       print_memstat
     end
   
     def print_memstat
       locations = exits = characters = 0
   
       ObjectSpace.each_object do |obj|
         locations += 1 if obj.class == Location
         exits += 1 if obj.class == Exit
         characters += 1 if obj.class == Character
       end
   
       statistics = """
!!       --------------------------
!!               STATISTICS
!!       --------------------------
!! 
!!         Locations: #{locations}
!!         Exits: #{exits}
!!         Characters: #{characters}
!! 
!!       --------------------------
!!     """
       puts statistics
     end
   
     def get_character_by_name_and_password(name, password)
       @characters.find { |c| c.name == name and c.password == password }
     end
   
     def create_new_character(name, session, password, description)
       character = Character.new(name, session, password, description)
       @characters.push(character)
       persist_world
       character
     end
   
     def persist_world
!!     File.open( 'db/characters.yaml', 'w' ) do |out|
!!       YAML.dump(@characters, out )
!!     end
!!   end
   
     def load_world
       entities = YAML.load_file('db/dikuworld.yaml')
       exits = entities.find_all { |e| e.class == Exit}
       @locations = entities.find_all { |e| e.class == Location}
       @locations.each do |location|
         location.instance_variable_set('@exits', Exits.new)
         location.instance_variable_set('@characters', [])
       end
       exits.each do |exit|
         exit.location.add_exit(exit)
       end
   
       @characters = YAML.load_file('db/characters.yaml')
     end
   end
================================================================================
lib/game/exit.rb
================================================================================
   class Exit
     attr_reader :name, :destination, :location
   
     def initialize(name, destination, description="", location=nil)
       @name, @destination, @description, @location =
               name, destination, description, location
     end
   
     def let_go(character)
       @destination.let_in(character, @location)
       character.move_to(@destination)
       character.look(@destination)
     end
   
     def description_for(character)
!!     @description
!!   end
!! end
================================================================================
lib/game/character.rb
================================================================================
   class Character
     attr_reader :name, :password, :location, :session,
                 :description, :inventory
   
     def initialize(name, session=nil, password=nil, description=nil)
       @name, @session, @password, @description =
       name, session, password, description
       @inventory = Inventory.new
     end
   
     def send_to_player(msg)
       @session.write msg
     end
   
     def move_to(location)
       @location = location
     end
   
     def bind_session(session)
       @session = session
     end
   
     def to_yaml_properties
!!     ['@name', '@password', '@description','@inventory']
!!   end
   
     def description_for(character)
!!     @description
!!   end
   
     def look(target)
       send_to_player(target.description_for(self))
     end
   
     def emote(emote_description)
       emote_message = "#{@name} #{emote_description}"
       @session.write "You emote: #{emote_message}"
       @location.send_to_all_except(self, emote_message)
     end
   
     def go(direction)
       begin
         @location.let_go(self, direction)
       rescue ExitNotAvailable
         @session.write "You can't go in that direction."
       end
     end
   
     def say(message)
       send_to_player("[color=cyan]You say '[/color]#{message}[color=cyan]'[/color]")
       notification = "[color=cyan]#{self.name} says '[/color]#{message}[color=cyan]'[/color]"
       @location.send_to_all_except(self, notification)
     end
   
     def get(item_name)
       begin
         item = @location.pick_item(item_name)
         @location.send_to_all_except(self, "#{self.name} gets #{item.description.downcase} from the floor") #TODO: some responsibilty issue. Location should do this.
         @inventory.add_item item
         @session.write("You get #{item.description.downcase}")
       rescue ItemNotAvailable
         @session.write("There is no '#{item_name}' here")
       end
     end
   
     def drop(item_name)
       begin
         item = @inventory.pick_item(item_name)
         @location.add_item(item)
         @location.send_to_all_except(self, "#{self.name} puts #{item.description.downcase} on the floor") #TODO: some responsibilty issue. Location should do this.
         @session.write("You put #{item.description.downcase} on the floor")
       rescue ItemNotAvailable
         @session.write("You don't have that item")
       end
     end
   
     def print_inventory()
       @session.write(@inventory.display)
     end
   end
================================================================================
lib/commands/say_command.rb
================================================================================
   class SayCommand
     attr_reader :message
     
     def initialize(character, *args)
       @character = character
       @message = args.first
     end
   
     def execute
       @character.say(@message)
       
     end
   end
================================================================================
lib/commands/get_command.rb
================================================================================
   class GetCommand
     attr_reader :item
   
     def initialize(character, *args)
       @character = character
       @item = args.first
     end
   
     def execute
       @character.get(@item)
     end
   end
================================================================================
lib/game/entity_not_available.rb
================================================================================
   class EntityNotAvailable < Exception
   end
================================================================================
lib/helpers/enumerable.rb
================================================================================
   module Enumerable
     def except(item)
       reject {|x| x == item }
     end
   end
================================================================================
lib/commands/emote_command.rb
================================================================================
   class EmoteCommand
     attr_reader :message
     
     def initialize(character, *args)
       @character = character
       @message = args.first
     end
   
     def execute
       @character.emote(@message)
     end
   end
================================================================================
lib/game/location.rb
================================================================================
   class Location
     attr_reader :title, :description, :characters
   
     include ItemsContainer
   
     def initialize(title, description)
       @title, @description = title, description
       @characters = []
       @exits = Exits.new
       initialize_items_container
     end
   
     def add_exit(exit)
       @exits.add(exit)
     end
   
     def add_character(character)
       @characters << character
       character.move_to(self)
     end
   
     def remove_character(character)
       @characters.delete(character)
     end
   
     def send_to_all_except(excluded_character, notification)
       @characters.except(excluded_character).each do |character|
         character.send_to_player(notification)
       end
     end
   
     def description_for(observer)
       LocationView.new(observer, @characters, @items, @exits, self).display
     end
   
     def exit_to(destination)
       @exits.find_by_destination(destination)
     end
   
     def let_go(character, direction)
       exit = @exits.find_by_name(direction)
       raise ExitNotAvailable if exit.nil?
       exit.let_go(character)
       remove_character(character)
       send_to_all_except(character, "#{character.name} leaves #{exit.name}")
     end
   
     def let_in(character, origin)
       @characters.push(character)
       exit_to_origin = exit_to(origin)
       if exit_to_origin
         notification = "#{character.name} arrives walking from #{exit_to_origin.name}"
       else
         notification = "#{character.name} appears out of thin air"
       end
       send_to_all_except(character, notification)
     end
   
     def get_entity_by_name(name)
       entity = @exits.find_by_name(name)
       entity = @characters.find { |c| c.name.downcase == name.downcase } if not entity
       entity = @items.find { |c| c.name.downcase == name.downcase } if not entity
       raise EntityNotAvailable if not entity
       entity
     end
   
   end
================================================================================
lib/commands/go_command.rb
================================================================================
   class GoCommand
     attr_reader :exit
     
     def initialize(character, *args)
       @character = character
       @exit = args.first #TODO: Rename to direction
     end
   
     def execute
       @character.go(@exit)
     end
   end
================================================================================
lib/protocol/telnet_filter.rb
================================================================================
   class TelnetFilter
     include TelnetCodes
   
     def initialize(socket)
       @socket = socket
     end
   
     def filter_input(input)
       input = remove_bare_line_feeds input
       input = remove_bare_carriage_returns input
       input = remove_bare_nuls input
       handle_options input
     end
   
     private
     LF_NOT_PRECEDED_BY_CR = Regexp.new("(^|[^#{CR}])#{LF}")
     def remove_bare_line_feeds(input)
       input.gsub(LF_NOT_PRECEDED_BY_CR, '\1')
     end
   
     CR_FOLLOWED_BY_A_NUL = Regexp.new("#{CR}#{NUL}")
     def remove_bare_carriage_returns(input)
       input.gsub(CR_FOLLOWED_BY_A_NUL, '')
     end
   
     JUST_A_NULL = Regexp.new("#{NUL}")
     def remove_bare_nuls(input)
       input.gsub(JUST_A_NULL, '')
     end
   
     def handle_options(input)
       while there_is_a_iac_in input
         if input.sub!(Regexp.new("(^|[^#{IAC}])#{IAC}[#{DO}#{DONT}](.)"), '\1')
           @socket.print "#{IAC+WONT}#{$2}"
         elsif input.sub!(Regexp.new("(^|[^#{IAC}])#{IAC}[#{WILL}#{WONT}](.)"), '\1')
           @socket.print "#{IAC+DONT}#{$2}"
         elsif input.sub!(Regexp.new("(^|[^#{IAC}])#{IAC}#{AYT}"), "\\1")
           @socket.puts "JewelMUD is still here"
         elsif input.sub!(Regexp.new("(^|[^#{IAC}])#{IAC}[^#{IAC}]"), "\\1")
         else
           input.sub!(Regexp.new("[#{IAC}]"), "")
         end
       end
       input
     end
   
     def there_is_a_iac_in(input)
       input.index("#{IAC}")
     end
   
   end
================================================================================
lib/game/authentication_process.rb
================================================================================
   class AuthenticationProcess
     def initialize(session, world)
       @session, @world = session, world
       @choices =
               {
                 "1" => lambda { login },
                 "2" => lambda { create_new_character }
               }
     end
   
     def execute
       @session.write("What would you like to do?\n" +
               "1) Login with existing character\n" +
               "2) Create a new character\n")
       choice = @session.read
       @choices[choice].call
     end
   
     private
     def create_new_character
       @name = ask_name
       @password = ask_new_password
       @description = ask_description
       @character = @world.create_new_character(@name, @session, @password, @description)
       visualize_welcome_message(@character.name)
       @character
     end
   
     def login
       @name = ask_name
       @session.write("Password:")
       @password = @session.read
       @character = @world.get_character_by_name_and_password(@name, @password)
       if not @character
         @session.write("Wrong details, try again.")
         return login
       end
       @character.bind_session(@session)
       @session.write("Welcome to Britannia #{@name}!")
       @character
     end
   
     def ask_name
       @session.write("What's your character name?")
       @session.read.capitalize
     end
   
     def visualize_welcome_message(name)
       @session.write("Welcome to Britannia #{name}!")
     end
   
     def ask_new_password
       @session.write("Choose a password for #{@name}:")
       @session.read
     end
   
     def ask_description
       @session.write "Choose a description that other players will " +
                       "see when they look to your character.\r\n" +
                       "Enter a line with END written in it when you finished."
       description = ""
       line = ""
       while line.downcase != "end"
         line = @session.read
         if line.downcase != "end"
           description += line + "\n"
           @session.write line
         end
       end
       description
     end
   
   end
================================================================================
lib/protocol/telnet_session.rb
================================================================================
   class TelnetSession
     def initialize(socket)
       @socket = socket
     end
   
     def read
       input = @socket.readline
       input = TelnetFilter.new(@socket).filter_input(input)
       input = adjust_backspace(input)
       input.chomp.strip
     end
   
     def write(text)
       return if @socket.closed?
       filtered_text = adjust_new_lines(replace_color_tags(text))
       @socket.print filtered_text
     end
   
     private
     COLOR_CODES = {
             "red" => "\e[31m",
             "blue" => "\e[34m",
             "green" => "\e[32m",
             "yellow" => "\e[33m",
             "cyan" => "\e[36m"
     }
   
     RESET_CODE = "\e[0m"
   
     def replace_color_tags(text)
       text.gsub(/\[color=([a-z]+)\]/im){ |m| COLOR_CODES[$1] }.
               gsub(/\[\/color\]/i, RESET_CODE)
     end
   
     def adjust_new_lines(text)
       text.gsub(/\n/,"\r\n") + "\r\n"
     end
   
     def adjust_backspace(text)
       return text if not text.include?("\b")
       a_character_followed_by_backspace = Regexp.new("(^|[^\b])\b")
       adjust_backspace text.sub(a_character_followed_by_backspace, "")
     end
   end
================================================================================
lib/commands/look_command.rb
================================================================================
   class LookCommand
     attr_reader :target
     
     def initialize(character, target_name=nil)
       @character = character
       @location = character.location
       @target_name = target_name
     end
   
     def execute
       begin
         @character.look(get_target(@target_name))
       rescue EntityNotAvailable
         @character.send_to_player("You can't see '#{@target_name}' here")
       end
     end
   
     private
     def get_target(target_name)
       return @location if target_name.empty?
       @location.get_entity_by_name(target_name)
     end
   end
================================================================================
lib/game/exit_not_available.rb
================================================================================
   class ExitNotAvailable < Exception
   end
================================================================================
lib/game/location_view.rb
================================================================================
   class LocationView
     def initialize(observer, characters, items, exits, location)
       @observer, @characters, @items, @exits, @location =
               observer, characters, items, exits, location
     end
   
     def display
       output = "You see:\n" +
               "[color=red]#{@location.title}[/color]\n" +
               "#{@location.description}"
       other_characters = @characters.except(@observer)
       other_characters.each do |p|
         output += "[color=yellow]#{p.name} is here\n[/color]"
       end
       @items.each do |i|
         output += "#{i.description} is here\n"
       end
       output += @exits.get_list_of_names
       output
     end
   end
================================================================================
lib/game/item_not_available.rb
================================================================================
   class ItemNotAvailable < Exception
   end
================================================================================
lib/game/items_container.rb
================================================================================
   module ItemsContainer
     def initialize_items_container
       @items = []  
     end
   
     def add_item(item)
       @items.push(item)
     end
   
     def pick_item(item_name)
       item = @items.find {|i| i.name.downcase == item_name.downcase}
       raise ItemNotAvailable if not item
       @items.delete(item)
     end
     
     def include?(item)
       @items.include?(item)
     end
   end
================================================================================
lib/protocol/telnet_codes.rb
================================================================================
   module TelnetCodes
     NUL = 0.chr
     LF = 10.chr
     CR = 13.chr
   
     IAC = 255.chr
     WILL = 251.chr
     WONT = 252.chr
     DO   = 253.chr
     DONT = 254.chr
   
     AYT = 246.chr
   end
================================================================================
lib/game/exits.rb
================================================================================
   class Exits
     def initialize(exits = [])
       @exits = exits
     end
   
     def find_by_name(name)
       @exits.find { |exit| exit.name.downcase == name.downcase}
     end
   
     def find_by_destination(destination)
       @exits.find { |exit| exit.destination == destination}
     end
   
     def add(exit)
       @exits << exit
     end
   
     def get_list_of_names
       exit_names = @exits.map {|exit| exit.name }
   
       return "" if exit_names.empty?
   
       if exit_names.size == 1
         return description_for_single_exit(exit_names)
       end
   
       description_for_multiple_exits(exit_names)
     end
   
     def description_for_single_exit(exit_names)
       "[color=green]You see only one exit leading #{exit_names.first}[/color]\n"
     end
   
     def description_for_multiple_exits(exit_names)
       names_separated = exit_names[0..-2].join(", ") + " and " + exit_names[-1]
       "[color=green]You see exits leading #{names_separated}.[/color]\n"
     end
   end
================================================================================
lib/commands/inventory_command.rb
================================================================================
   class InventoryCommand
     attr_reader :item
   
     def initialize(character, *args)
       @character = character
       @item = args.first
     end
   
     def execute
       @character.print_inventory
     end
   end
================================================================================
lib/commands/do_nothing.rb
================================================================================
   class DoNothing
     def execute
     end
   end
================================================================================
lib/command_factory.rb
================================================================================
   class CommandFactory
     attr_accessor :aliases
   
     def initialize
       @aliases = {}
     end
   
     def parse(input, character)
       return DoNothing.new if input.empty?
       command_name, arguments = split_input(input)
       command_class = get_command_by_name(command_name)
       command_class.new(character, arguments)
     end
   
     private
     def get_command_by_name(name)
       command_class = ObjectSpace.each_object.find do |o|
         o.class == Class and o.name == "#{name.capitalize}Command"
       end
       command_class || NoCommandFound
     end
   
     def split_input(input)
       input = parse_through_alias_matcher(input)
       input =~ /^(\w+)(.*)/i
       return $1, $2.strip
     end
   
     def parse_through_alias_matcher(input)
       input =~ /^(\w+)(.*)/i
       if @aliases.has_key?($1.downcase)
         return input.gsub(/^(\w+)/, @aliases[$1.downcase])
       end
       input
     end
   end
================================================================================
lib/commands/drop_command.rb
================================================================================
   class DropCommand
     attr_reader :item
   
     def initialize(character, *args)
       @character = character
       @item = args.first
     end
   
     def execute
       @character.drop(@item)
     end
   end
================================================================================
lib/commands/shutdown_command.rb
================================================================================
   class ShutdownCommand
     attr_reader :args
     
     def initialize(character, *args)
       @character = character
       @args = args
     end
   
     def execute
       Game.instance.shutdown
     end
   end
================================================================================
lib/game/inventory.rb
================================================================================
   require 'lib/game/items_container'
   class Inventory
     include ItemsContainer
   
     def initialize
       initialize_items_container
     end
   
     def display
       output = "[color=yellow]In your hands:[/color]\n"
       @items.each { |i| output += "#{i.description}\n" }
       output += "Nothing...\n" if @items.empty?
       output
     end
   end
